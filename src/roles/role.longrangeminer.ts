

import { Id } from "../../typings/helpers";
import { Lremove } from "../libs/general.functions";
import { remove, register as _register, harvest } from "../libs/general.sourceregistering";
import { report } from "./../libs/roomReporting"
import { Allies } from "../libs/allyLibs/allyConsts"
import { RoomObject } from "../../typings/room-object";
import { AnyStoreStructure, Structure, StructureController, StructureLink } from "../../typings/structure";
// Comments below this are generated by chatgpt, so it may be a little inaccurate
/**
 *
 * @param {Creep} creep
 * @param {String} id
 */

function dismantleInvaderCore(creep: Creep, id: Id<any>) {
    let item = Game.getObjectById(id)
    if (item !== null) {
        if (creep.dismantle(item) === ERR_NOT_IN_RANGE) {
            creep.moveTo(item)
        }
    }
}
export function tick(mainRoom:Room) {
    let run: number = 0
    if(Memory.miningrooms.length<Memory.longrangemining.length) {
        for(let amog of Memory.longrangemining) {
            let confirm = Memory.miningrooms.filter((Mroom)=>Mroom.room===amog?.room).length
            if(confirm===0&&amog.room!==undefined) Memory.miningrooms.push({room:amog.room,usedSegment:0})
        }
    }
    report.formatBasic("no clue",JSON.stringify(Memory.miningrooms))
    for (const E of Memory.miningrooms) {

        // Retrieve and rotate the first room in the update queue
        let temp:number = run
        // Get room information and mining data from memory
        let RoomObject = Memory.miningrooms[temp];
        let info = Memory.longrangemining[temp];
        // Initialize mining data if it doesn't exist
        if (info === undefined) {
            info = { creeps: [], sources: [], wantcreeps: 0, room: undefined };
            Memory.longrangemining[temp] = info;
        }
        if (info.room === undefined&&RoomObject!==undefined) {
            for(let R of Memory.miningrooms) {
                if(Memory.longrangemining.some((a)=>a.room===R.room)===false) {

                    Memory.longrangemining[temp].room = R.room
                }
            }
        } else {
            for (let object of Memory.miningrooms) {
                if (object.room === Memory.longrangemining[temp].room&&Memory.longrangemining.some((a)=>a.room==object.room)===false) {
                    RoomObject = object
                    break
                }
            }
        }
        if(Memory.longrangemining[temp].room!==undefined) {
            if(Memory.miningrooms.some((a)=>a.room===Memory.longrangemining[temp].room)===false) {
                if(Memory.longrangemining[temp].creeps.length>0) {
                    for(let I of Memory.longrangemining[temp].creeps) {
                        Game.creeps[I].memory.cachsource=undefined
                        Game.creeps[I].memory.check = undefined
                    }
                    Memory.storedcreeps.concat(Memory.longrangemining[temp].creeps)
                }
                Memory.longrangemining.splice(temp,1)
                console.log("A")
                break;
            }
        }
        let filter = Memory.longrangemining.filter((a)=>a.room===Memory.longrangemining[temp].room)
        if(filter.length>1) {
            let index = Memory.longrangemining.lastIndexOf(filter[filter.length-1])
            if(Memory.longrangemining[index].creeps.length>0) {
                Memory.storedcreeps.concat(Memory.longrangemining[index].creeps)
            }
            if(index>=temp) {
                temp -= 1
            }
            Memory.longrangemining.splice(index,1)
            console.log("B")
        }
        // If no creeps are currently wanted for mining, check if there's a creep available to send
        if (Memory.longrangemining[temp].wantcreeps == 0) {
            if (Memory.longrangemining[temp].creeps.length > 0) {
                // Move an existing creep to the room to estimate the required miners
                let creep = Game.creeps[Memory.longrangemining[temp].creeps[0]];
                if(creep===undefined) {
                    Memory.longrangemining[temp].creeps.shift()
                    return
                }
                let roompos = new RoomPosition(25, 25, RoomObject.room);
                creep.moveTo(roompos, { reusePath: 40, visualizePathStyle: { stroke: '#ffffff' } });

                // Once the creep is in the target room, determine the number of mining sources
                if (creep.room.name == RoomObject.room) {
                    Memory.longrangemining[temp].wantcreeps = creep.room.find(FIND_SOURCES).length;
                }
            } else {
                // Request a new creep for the room if none are available
                let request = creeprequest(Memory.longrangemining[temp]);
                if (request !== null) {
                    Memory.longrangemining[temp].creeps.push(request);
                }
            }
        } else {
            // If more creeps are needed, request additional creeps
            if (Memory.longrangemining[temp].creeps.length < Memory.longrangemining[temp].wantcreeps) {
                let request = creeprequest(Memory.longrangemining[temp]);
                if (request !== null) {
                    Memory.longrangemining[temp].creeps.push(request);
                }
            }
            let allsettled = 1
            // Iterate through all assigned creeps for this mining room
            let filter:string[] = []
            for (const nameold in Memory.longrangemining[temp].creeps) {
                let Cname = Memory.longrangemining[temp].creeps[nameold];
                let creep = Game.creeps[Cname];
                if (creep !== undefined) {
                    if(creep.memory.registeredsource!==undefined) {
                        //@ts-ignore
                        filter.push(creep.memory.registeredsource)
                    }
                    if (creep.memory.check !== 1) {
                        allsettled = 0
                    }
                }
            }
            Memory.longrangemining[temp].sources = Memory.longrangemining[temp].sources.filter((a)=>filter.indexOf(a)!==-1)
            if(Memory.longrangemining[temp].claimer!==undefined) {
                //@ts-ignore
                let claimer:Creep = Game.creeps[Memory.longrangemining[temp].claimer]
                if (claimer == undefined) {
                    Memory.longrangemining[temp].claimer = undefined
                }
                if (claimer.memory.reserving !== undefined) {
                    if (claimer.room.name !== claimer.memory.reserving) {
                        claimer.moveTo(new RoomPosition(25, 25, claimer.memory.reserving), { reusePath: 40 })
                    } else {
                        let check: StructureController[] = claimer.room.find(FIND_STRUCTURES, {
                            filter: function (structure) {
                                return structure.structureType == STRUCTURE_CONTROLLER
                            }
                        })
                        if (check) {
                            if (claimer.reserveController(check[0]) == ERR_NOT_IN_RANGE) claimer.moveTo(check[0],{reusePath:40})
                            else if(claimer.room.controller?.sign?.username!==claimer.owner.username) claimer.signController(check[0],"01000111 01100101 01101111 00100000 01101101 01101001 01101110 01101001 01101110 01100111")
                        }
                    }
                } else {
                    claimer.say("roomless")
                    report.formatBasic("*", "claimer " + claimer.name + " is roomless!")
                }
            }
            for (const Cname of Memory.longrangemining[temp].creeps) {
                let creep: Creep = Game.creeps[Cname];
                // If the creep is dead, remove it from memory
                if ((Cname in Game.creeps)===false) {
                    try {
                        let creepmem = { memory: Memory.creeps[Cname] }
                        remove("sources", creepmem, true, Memory.longrangemining[temp]);
                    } catch (e) { console.log("Error at line 68 of longrangeharvesting: " + e) }
                    Memory.longrangemining[temp].creeps.splice(Memory.longrangemining[temp].creeps.indexOf(Cname), 1);
                    break;
                }
                new RoomVisual(creep.room.name).text('LRM, mining for room: ' + RoomObject.room, creep.pos.x, creep.pos.y + 1, { align: 'center', font: 0.3, color: 'blue', stroke: "white", strokeWidth: 0.01 });
                if (creep.memory.registeredsource !== undefined && (typeof creep.memory.registeredsource === "string")) {
                    //@ts-ignore
                    Game.map.visual.line(creep.pos, Game.getObjectById(creep.memory.registeredsource).pos, { opacity: 1 });
                    let color = "#ff0000"
                    if (creep.memory.check === 1) color = "#439D47"
                    //@ts-ignore
                    Game.map.visual.circle(Game.getObjectById(creep.memory.registeredsource).pos, { fill: color, radius: 1, stroke: color, opacity: 1 })
                }
                let hostiles: Creep[] | Structure[]
                hostiles = creep.room.find(FIND_HOSTILE_CREEPS, {
                    filter: function (creep:Creep) {
                        return Allies.indexOf(creep.owner.username) === -1 &&
                        (creep.getActiveBodyparts(ATTACK)>0||creep.getActiveBodyparts(RANGED_ATTACK)>0||creep.getActiveBodyparts(HEAL)>0||creep.getActiveBodyparts(CLAIM)>0)
                    }
                })
                let friendly = creep.room.find(FIND_MY_CREEPS, {
                    filter: function (creep:Creep) {
                        return (creep.getActiveBodyparts(ATTACK)>0||creep.getActiveBodyparts(RANGED_ATTACK)>0||creep.getActiveBodyparts(HEAL)>0)
                    }
                })

                if (hostiles.length === 0) {
                    let TSdumb:Structure[] = creep.room.find(FIND_HOSTILE_STRUCTURES,{filter:(a)=>a.structureType!==STRUCTURE_RAMPART})
                    hostiles = TSdumb
                }
                if(hostiles.length > 0) {
                    creep.moveTo(mainRoom.getMasterSpawn(),{reusePath:40})
                    if(creep.store.energy>0) creep.drop(RESOURCE_ENERGY)
                    if (friendly.length===0) {
                        console.log("LRM enemy detection")
                        let alreadyrequested = -1
                        for (let temp in Memory.defenserequests) {
                            if (Memory.defenserequests[temp].room == creep.room.name) {
                                alreadyrequested = 1
                            }
                        }
                        if (alreadyrequested == -1) {
                            Memory.defenserequests.push({ x: creep.pos.x, y: creep.pos.y, room: creep.room.name })
                        }
                        global.defenseNeeded = 40
                    }
                    continue;
                }
                if (allsettled) {
                    if(typeof creep.memory.registeredsource!=="number"&&creep.memory.registeredsource!==undefined) {
                        if(Game.getObjectById(creep.memory.registeredsource)!==undefined) {
                            //@ts-ignore
                            if(Game.getObjectById(creep.memory.registeredsource).energy===0) continue
                        }
                    }
                    if (creep.ticksToLive !== undefined && creep.ticksToLive > 10) {
                        // Register creep to a source and initiate harvesting
                        if (harvest(creep) == OK) {
                            if (creep.memory.check !== 1) global.updatecache = 100
                            creep.memory.check = 1
                        }
                        if (creep.store[RESOURCE_ENERGY] > 40) {
                            creep.memory.check = 1
                            let linkmining:StructureLink[] = []
                            if (creep.memory.linktomine === undefined) {
                                //@ts-ignore
                                linkmining = creep.pos.findInRange(FIND_MY_STRUCTURES, 3, {
                                    filter: function (structure) {
                                        return structure.structureType === "link"
                                    }
                                }).sort((a,b)=>a.pos.getRangeTo(creep)-b.pos.getRangeTo(creep))
                                if (linkmining.length > 0) {
                                    creep.moveTo(linkmining[0])
                                    creep.memory.linktomine = linkmining[0].id
                                }
                            }
                            //@ts-ignore
                            if (Game.getObjectById(creep.memory.linktomine) === undefined) {
                                creep.memory.linktomine = undefined
                            }
                            if (creep.memory.linktomine !== undefined) {
                                //@ts-ignore
                                if (creep.transfer(Game.getObjectById(creep.memory.linktomine), RESOURCE_ENERGY) !==OK) {
                                    //@ts-ignore
                                    creep.moveTo(Game.getObjectById(creep.memory.linktomine))
                                }
                            } else {
                                creep.drop(RESOURCE_ENERGY)
                            }
                        }
                    } else {
                        remove("sources", creep, true, Memory.longrangemining[temp]);
                        creep.say("I die :(")
                    }
                    continue
                }
                if (creep.memory.check === 1) {
                    //@ts-ignore
                    if(Game.getObjectById(creep.memory.registeredsource)!==undefined) if(Game.getObjectById(creep.memory.registeredsource).energy===0) continue
                    if (creep.ticksToLive !== undefined && creep.ticksToLive > 10) {
                        creep.memory.state = "mining"
                        // Register creep to a source and initiate harvesting
                        if (harvest(creep) == OK) {
                            if (creep.memory.check !== 1) global.updatecache = 100
                            creep.memory.check = 1
                        }
                        if (creep.store[RESOURCE_ENERGY] > 40) {
                            creep.memory.check = 1
                            let linkmining = creep.pos.findInRange(FIND_MY_STRUCTURES, 3, {
                                filter: function (structure) {
                                    return structure.structureType === STRUCTURE_LINK
                                }
                            })
                            if (linkmining.length > 0) {
                                if (creep.transfer(linkmining[0], RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
                                    creep.moveTo(linkmining[0], { maxOps: 50 })
                                }
                            } else {
                                creep.drop(RESOURCE_ENERGY)
                            }
                        }
                    } else {
                        remove("sources", creep, true, Memory.longrangemining[temp]);
                    }
                    continue
                }
                // Display label indicating the creep's mining task and target room

                // If the creep's energy is not full and it should be mining
                if (creep.memory.state !== "moving") {
                    if (creep.room.name != RoomObject.room||(creep.pos.x>49||creep.pos.x<2||creep.pos.y>49||creep.pos.y<2)) {

                        creep.moveTo(new RoomPosition(25, 25, RoomObject.room), { reusePath: 40, visualizePathStyle: { stroke: '#ffffff' } });
                        //if(creep.memory._move) {
                        //    creep.placeRoadByPath(creep.memory._move.path,"LRMmid")
                        //}

                    } else {
                        if (creep.memory.check === 1 && creep.getActiveBodyparts(WORK) >= 12) {
                            continue
                        }
                        if(creep.memory.registeredsource===undefined) {
                            creep.moveTo(new RoomPosition(25, 25, RoomObject.room), { reusePath: 40, visualizePathStyle: { stroke: '#ffffff' } })
                        }
                        info = _register("sources", creep, true, Memory.longrangemining[temp]);
                        if (harvest(creep) == OK) {
                            if (creep.memory.check !== 1) global.updatecache = 100
                            creep.memory.check = 1
                        }
                    }
                }
            }
        }
        run += 1
    }

}
export function claimerrequest(info: any) {
    if (Memory.storedcreeps.length > 0) {
        //@ts-ignore
        let creep = Memory.claimercreeps[0];
        Memory.storedcreeps = Lremove(Memory.storedcreeps, creep);
        return creep;
    }
    return null;
}
// Request a new creep from stored creep memory, if available
export function creeprequest(info: any) {
    if (Memory.storedcreeps.length > 0) {
        let creep = Memory.storedcreeps[0];
        Memory.storedcreeps = Lremove(Memory.storedcreeps, creep);
        return creep;
    }
    return null;
}
