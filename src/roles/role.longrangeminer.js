
import { Lremove } from "../libs/general.functions";
import { remove, register as _register, harvest } from "../libs/general.sourceregistering";
// Comments below this are generated by chatgpt, so it may be a little inaccurate
function reverseDirectionTo(target) {
    let reverseDict = {
        3: 7,          // RIGHT → LEFT
        7: 3,          // LEFT → RIGHT
        1: 5,          // TOP → BOTTOM
        5: 1,          // BOTTOM → TOP
        8: 6,          // TOP_LEFT → BOTTOM_LEFT
        6: 8,          // BOTTOM_LEFT → TOP_LEFT
        2: 4,          // TOP_RIGHT → BOTTOM_RIGHT
        4: 2           // BOTTOM_RIGHT → TOP_RIGHT
    }
    return reverseDict[creep.pos.getDirectionTo(target)]
}
/**
 *
 * @param {Creep} creep
 * @param {String} id
 */
function dismantleInvaderCore(creep,id) {
    let item = Game.getObjectById(id)
    if(item!==null) {
        if(creep.dismantle(item)===ERR_NOT_IN_RANGE) {
            creep.moveTo(item)
        }
    }
}
    export function tick () {
            for (const run in Memory.miningrooms) {

                try {

                    // Retrieve and rotate the first room in the update queue
                    let temp = run

                    // Get room information and mining data from memory
                    let RoomObject = Memory.miningrooms[temp];
                    let info = Memory.longrangemining[temp];
                    let mapVisual = new RoomPosition(0,0,RoomObject.room)
                    Game.map.visual.rect(mapVisual,50,50,{fill:"transparent",stroke:"#F57F17",strokeWidth:2})
                    // Initialize mining data if it doesn't exist
                    if (info === undefined) {
                        info = { creeps: [], sources: [], wantcreeps: 0,room:undefined };
                        Memory.longrangemining[temp] = info;
                    }
                    if(Memory.longrangemining[temp].room===undefined) {
                        Memory.longrangemining[temp].room=RoomObject.room
                    } else {
                        for(let object of Memory.miningrooms) {
                            if(object.room===Memory.longrangemining[temp].room) {
                                RoomObject = object
                                break
                            }
                        }
                    }
                    // If no creeps are currently wanted for mining, check if there's a creep available to send
                    if (Memory.longrangemining[temp].wantcreeps == 0) {
                        if (Memory.longrangemining[temp].creeps.length > 0) {
                            // Move an existing creep to the room to estimate the required miners
                            let creep = Game.creeps[Memory.longrangemining[temp].creeps[0]];
                            let roompos = new RoomPosition(25, 25, RoomObject.room);
                            creep.moveTo(roompos, { reusePath: 40, visualizePathStyle: { stroke: '#ffffff' } });

                            // Once the creep is in the target room, determine the number of mining sources
                            if (creep.room.name == RoomObject.room) {
                                Memory.longrangemining[temp].wantcreeps = creep.room.find(FIND_SOURCES).length;
                            }
                        } else {
                            // Request a new creep for the room if none are available
                            let request = creeprequest(Memory.longrangemining[temp]);
                            if (request !== null) {
                                Memory.longrangemining[temp].creeps.push(request);
                            }
                        }
                    } else {
                        // If more creeps are needed, request additional creeps
                        if (Memory.longrangemining[temp].creeps.length < Memory.longrangemining[temp].wantcreeps) {
                            let request = creeprequest(Memory.longrangemining[temp]);
                            if (request !== null) {
                                Memory.longrangemining[temp].creeps.push(request);
                            }
                        }
                        let allsettled = 1
                        // Iterate through all assigned creeps for this mining room
                        for (const nameold in Memory.longrangemining[temp].creeps) {
                            let Cname = Memory.longrangemining[temp].creeps[nameold];
                            let creep = Game.creeps[Cname];
                            if(creep!==undefined) {
                                if(creep.memory.check !== 1) {
                                    allsettled = 0
                                }
                            }
                        }
                        for (const nameold in Memory.longrangemining[temp].creeps) {
                            let Cname = Memory.longrangemining[temp].creeps[nameold];
                            let creep = Game.creeps[Cname];
                            // If the creep is dead, remove it from memory
                            if (creep === undefined) {
                                try {
                                    let creepmem = { memory: Memory.creeps[Cname] }
                                    remove("sources", creepmem, true, Memory.longrangemining[temp]);
                                } catch (e) { console.log("Error at line 68 of longrangeharvesting: " + e) }
                                Memory.longrangemining[temp].creeps = Lremove(Memory.longrangemining[temp].creeps, Cname);
                                break;
                            }
                            new RoomVisual(creep.room.name).text('LRM, mining for room: ' + RoomObject.room, creep.pos.x, creep.pos.y + 1, { align: 'center', font: 0.3, color: 'blue', stroke: "white", strokeWidth: 0.01 });
                            if(creep.memory.registeredsource!==undefined) {
                                Game.map.visual.line(creep.pos,Game.getObjectById(creep.memory.registeredsource).pos,{opacity:1});
                                let color = "#ff0000"
                                if(creep.memory.check===1) color = "#439D47"
                                Game.map.visual.circle(Game.getObjectById(creep.memory.registeredsource).pos,{fill: color, radius: 1, stroke: color,opacity:1})
                            }


                            if(allsettled) {
                                if (creep.ticksToLive > 10) {
                                    // Register creep to a source and initiate harvesting
                                    if(global.timer%2===0&&creep.getActiveBodyparts(WORK)>=12) {
                                        continue
                                    }
                                    if (harvest(creep) == OK) {
                                        if(creep.memory.check !== 1) global.updatecache = 400
                                        creep.memory.check = 1
                                    }
                                    if (creep.store[RESOURCE_ENERGY] > 40) {
                                        creep.memory.check = 1
                                        let linkmining = []
                                        if(creep.memory.linktomine===undefined) {
                                            linkmining = creep.pos.findInRange(FIND_MY_STRUCTURES,3,{filter: function(structure) {
                                                return structure.structureType===STRUCTURE_LINK
                                            }})
                                            if(linkmining.length>0) {
                                                creep.memory.linktomine = linkmining[0].id
                                            }
                                        }
                                        if(Game.getObjectById(creep.memory.linktomine)===undefined) {
                                            creep.memory.linktomine = undefined
                                        }
                                        if(creep.memory.linktomine!==undefined) {
                                            if(creep.transfer(Game.getObjectById(creep.memory.linktomine),RESOURCE_ENERGY)===ERR_NOT_IN_RANGE) {
                                                creep.move(creep.pos.getDirectionTo(Game.getObjectById(creep.memory.linktomine)))
                                            }
                                        } else {
                                            creep.drop(RESOURCE_ENERGY)
                                        }
                                    }
                                } else {
                                    remove("sources", creep, true, Memory.longrangemining[temp]);
                                    creep.say("I die :(")
                                }
                                continue
                            }
                            if(creep.memory.check===1) {
                                if (creep.ticksToLive > 10) {
                                    creep.memory.state="mining"
                                    if(global.timer%2===0&&creep.getActiveBodyparts(WORK)>=12) {
                                        continue
                                    }
                                    // Register creep to a source and initiate harvesting
                                    if (harvest(creep) == OK) {
                                        if(creep.memory.check !== 1) global.updatecache = 400
                                        creep.memory.check = 1
                                    }
                                    if (creep.store[RESOURCE_ENERGY] > 40) {
                                        creep.memory.check = 1
                                        let linkmining = creep.pos.findInRange(FIND_MY_STRUCTURES,3,{filter: function(structure) {
                                            return structure.structureType===STRUCTURE_LINK
                                        }})
                                        if(linkmining.length>0) {
                                            if(creep.transfer(linkmining[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE) {
                                                creep.moveTo(linkmining[0],{maxOps:50})
                                            }
                                        } else {
                                            creep.drop(RESOURCE_ENERGY)
                                        }
                                    }
                                } else {
                                    remove("sources", creep, true, Memory.longrangemining[temp]);
                                    creep.say("I die :(")
                                }
                                continue
                            }
                            // Display label indicating the creep's mining task and target room
                            let hostiles = creep.room.find(FIND_HOSTILE_CREEPS, {filter: function(creep) {
                                return creep.owner.username !== "chungus3095"
                            }})
                            if(hostiles.length===0) hostiles = creep.room.find(FIND_HOSTILE_STRUCTURES, {filter: function(creep) {
                                return creep.owner.username !== "chungus3095"
                            }})
                            if (hostiles.length > 0) {
                                let alreadyrequested = -1
                                for (let temp in Memory.defenserequests) {
                                    if (Memory.defenserequests[temp].room == creep.room.name) {
                                        alreadyrequested = 1
                                    }
                                }
                                if (alreadyrequested == -1) {
                                    Memory.defenserequests.push({ x: creep.pos.x, y: creep.pos.y, room: creep.room.name })
                                }
                                global.defenseNeeded = 40
                            }
                            // If the creep's energy is not full and it should be mining
                            if (creep.memory.state !== "moving") {
                                if (creep.room.name != RoomObject.room) {

                                    creep.moveTo(new RoomPosition(25, 25, RoomObject.room), { reusePath: 40, visualizePathStyle: { stroke: '#ffffff' } });
                                    //if(creep.memory._move) {
                                    //    creep.placeRoadByPath(creep.memory._move.path,"LRMmid")
                                    //}

                                } else {
                                    if(global.timer%2===0&&creep.memory.check === 1&&creep.getActiveBodyparts(WORK)>=12) {
                                        continue
                                    }
                                    info = _register("sources", creep, true, Memory.longrangemining[temp]);
                                    if (harvest(creep) == OK) {
                                        if(creep.memory.check !== 1) global.updatecache = 400
                                            creep.memory.check = 1
                                    }
                                }
                            }
                        }
                    }
                } catch (err) {
                    console.log("site " + run + " errored out with error " + err)
                }
            }

    }
    export function claimerrequest(info) {
        if (Memory.storedcreeps.length > 0) {
            let creep = Memory.claimercreeps[0];
            Memory.storedcreeps = Lremove(Memory.storedcreeps, creep);
            return creep;
        }
        return null;
    }
    // Request a new creep from stored creep memory, if available
    export function creeprequest (info) {
        if (Memory.storedcreeps.length > 0) {
            let creep = Memory.storedcreeps[0];
            Memory.storedcreeps = Lremove(Memory.storedcreeps, creep);
            return creep;
        }
        return null;
    }
