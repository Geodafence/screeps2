// Comments are generated by ChatGPT, so they may be a little inaccurate

import { AnyStoreStructure, AnyStructure, Structure, StructureStorage } from "../typings/structure";
import { remove, register as _register, harvest } from "./libs/general.sourceregistering";
import { ConstructionSite } from "../typings/construction-site";


    /** @param {Creep} creep **/
    export function run(creep:Creep,spawn:StructureSpawn) {
        // Array of possible extra tasks when there are no construction sites
        let rand = ["upgrading"];
        if(spawn.room.controller!==undefined&&spawn.room.controller.level < 3) {
            rand = ["upgrading","repairing"];
        }
        // Switch to harvesting mode if the creep is building and runs out of energy
        if(creep.memory.state && creep.store[RESOURCE_ENERGY] == 0) {
            creep.memory.state = false;
            // Randomly choose an extra task: "upgrading" or "repairing"
            creep.memory.extratask = rand[Math.round(Math.random() * rand.length)];
        }

        // Switch to building mode if the creep is full of energy
        if(!creep.memory.state && creep.store.getFreeCapacity() == 0) {
            creep.memory.state = true;
            // Unregister the creep from its assigned source when it starts building
            remove("buildersources", creep);
        }

        // If the creep is in building mode
        if(creep.memory.state) {
            // Find construction sites in the room
            let find = creep.room.find(FIND_CONSTRUCTION_SITES);
            find.sort((a,b)=>Number(b.structureType===STRUCTURE_STORAGE)-Number(a.structureType===STRUCTURE_STORAGE))
            let targets = creep.pos.findClosestByRange(FIND_CONSTRUCTION_SITES);
            if(find.length>0) {
                if(find[0].structureType===STRUCTURE_STORAGE) {
                    targets = find[0]
                }
            }
            let emergancyrepair = creep.room.find(FIND_STRUCTURES,{filter: (struct: Structure) => struct.hits < struct.hitsMax*0.25&&struct.structureType!==STRUCTURE_RAMPART&&struct.structureType!==STRUCTURE_WALL})
            // If construction sites are available, build at the nearest site
            if(targets&&emergancyrepair.length===0) {
                if(creep.build(targets) == ERR_NOT_IN_RANGE) {
                    creep.moveTo(targets, {reusePath: 40, visualizePathStyle: {stroke: '#8f02f4'}});
                }
            } else {
                if(emergancyrepair.length>0) {
                    creep.memory.extratask = "repairing"
                }
                // If no construction sites, perform extra task (repair or upgrade)
                if(creep.memory.extratask == "repairing") {
                    // Find damaged structures in the room
                    const targets = creep.room.find(FIND_STRUCTURES, {
                        filter: object => object.hits < object.hitsMax
                    });

                    // Sort by damage level (most damaged first)
                    targets.sort((a, b) => a.hits - b.hits);

                    // If damaged structures are found, repair the closest one
                    if(targets.length > 0) {
                        if(creep.repair(targets[0]) == ERR_NOT_IN_RANGE) {
                            creep.moveTo(targets[0],{reusePath: 40});
                        }
                    } else {
                        creep.memory.extratask = "upgrading"
                    }

                } else {
                    // If the extra task is upgrading, move to and upgrade the room controller
                    //@ts-ignore
                    creep.moveTo(spawn.room.controller, {reusePath: 40,range:3, visualizePathStyle: {stroke: '#f46f02'}});
                    //@ts-ignore
                    if(creep.upgradeController(spawn.room.controller) == ERR_NOT_IN_RANGE) {
                    }
                }
            }
        } else {
			let targets = creep.room.find(FIND_STRUCTURES, {
                filter: (structure) => {
                    return (structure.structureType == STRUCTURE_STORAGE && structure.store[RESOURCE_ENERGY] > 100000) ||
                    (structure.structureType===STRUCTURE_SPAWN && structure.store[RESOURCE_ENERGY]===300&&structure.room.storage===undefined&&Memory.longrangemining[Memory.longrangemining.length-1].creeps.length>0)
                    || (structure.structureType===STRUCTURE_CONTAINER&&structure.store[RESOURCE_ENERGY]>0)
                }
        	});
			if(targets.length > 0) {
                let trytest = creep.withdraw(targets[0],RESOURCE_ENERGY)
            	if(trytest == ERR_NOT_IN_RANGE) {
                	creep.moveTo(targets[0],{reusePath: 10})
                }
			} else {
                let targets = creep.pos.findClosestByRange(FIND_DROPPED_RESOURCES, {
                    filter: (res) => {
                        return res.resourceType===RESOURCE_ENERGY
                    }
                });
                if(targets) {
                    let trytest = creep.pickup(targets)
                    if(trytest == ERR_NOT_IN_RANGE) {
                        creep.moveTo(targets,{reusePath: 10})
                    }
                }
				// Register the creep to a source if not already registered
				if(creep.memory.registeredsource == undefined || creep.memory.registeredsource == 0) {
				    _register("buildersources", creep);
				}
				// Harvest energy from the assigned source
				harvest(creep);
			}
        }
    }

