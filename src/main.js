// Comments are generated by ChatGPT, so they may be a little inaccurate
if("harvesters" in Memory != true) {
    // Initialization of memory properties for the first loop
    console.log("first time loop is restarted");
    Memory.longRangeBuilders = new Array();
    Memory.claimers = new Array();
    Memory.LRMpaths = new Object();
    Memory.fighters = new Array();
    Memory.haulers = new Array();
    Memory.assignedids = 0;
    Memory.usedsources = new Array();
    Memory.buildersources = new Array();
    Memory.upgradersources = new Array();
    Memory.roomCache = new Object();
    Memory.builderlevel = 1;
}
if("storedcreeps" in Memory != true) {
    // Initialization of memory properties for stored creeps and mining
    console.log("loading long range miners!");
    Memory.storedcreeps = [];
    Memory.segmentRequests = [];
    Memory.longrangemining = [];
    Memory.longrangeminingcreeps = [];
}

// Setup mining rooms and global update lists.
Memory.miningrooms = [
    {room: "E8S32", usedSegment: 0},
    {room: "E8S33", usedSegment: 0},
];
global.nextupdate = [];
global.nexttick = [];
global.avgcpu = []
global.cputrend = [20]
global.cache = {}
global.needMins = 0

// Import necessary modules for various roles and functions
import { run as harvtick } from './roles/role.harvester';
import { newharvcheck, newbuildcheck, newhaulercheck, newcombatcheck, createqueen } from "./handler.newunits";
import { run as buildertick } from "./roles/role.builder";
import { run as combattick } from "./roles/role.combat";
import { remove } from "./libs/general.sourceregistering";
import { tick as LRBtick } from "./roles/role.longrangebuilder";
import { tick as remotetick } from "./roles/role.longrangeminer";
import { getTrueDistance, Lremove } from "./libs/general.functions";
import { tick as haulertick } from "./roles/role.hauler";
import { run as minharvtick } from "./roles/role.mineralharv";
import { tick as terminaltick } from "./libs/terminalCalculator";
import { tick as linktick } from "./structure.link";
import "./libs/spawnUtils";
import { tick as queentick } from "./roles/role.queen";
import { isUndefined } from 'lodash';
import { run as refillTick } from './roles/role.buildrefill';
if(global.fixticks === undefined) {
    global.fixticks = 0
}
global.spawnqueen = createqueen
global.defenseNeeded = 0
global.timer = 0
global.updatecache = 400
console.log("restarting loop");
//var ramparttest = require("rampartcalc")
//console.log(ramparttest.findOptimalRamparts(Game.rooms["E52S18"]))
export function loop () {
    if(Game.cpu.bucket < 500) {
        console.log("extremely low cpu bucket, terminating")
        return
    }
    RawMemory.setActiveSegments([1]);
    Memory.haulerlevel = 0
    global.timer+=1
    global.fixticks += 1
    global.updatecache += 1
    if(global.restartEco!==undefined) console.log("consolidating eco to "+global.restartEco)
    if(global.updatecache > 400) {
        console.log("updating cache")
        let full = 0
        for(const T in Memory.longrangemining) {
            let I = Memory.longrangemining[T]
            for(const name in I.creeps) {
                let creep = Game.creeps[I.creeps[name]]
                if(creep !== undefined) {
                    let linkmining = creep.pos.findInRange(FIND_MY_STRUCTURES,3,{filter: function(structure) {
                        return structure.structureType===STRUCTURE_LINK
                    }})
                if(linkmining.length===0&&creep!==null&&creep!==undefined) {
                    let dist = getTrueDistance(new RoomPosition(Game.spawns.Spawn1.pos.x,Game.spawns.Spawn1.pos.y,Game.spawns.Spawn1.room.name),new RoomPosition(creep.pos.x,creep.pos.y,creep.room.name))
                    if(creep.room.controller&&creep.room.controller.reservation) dist = dist * 1.5
                    let divide = creep.getActiveBodyparts(WORK)/6
                    if(divide>1) divide=1
                    dist=dist*divide
                    full += dist
                }
            }
            }
        }
        let multi=0
        for(let key in Game.spawns) multi+=1
        Memory.haulerneeded = (Math.round((full)/2.5))
        global.updatecache = 0
    }
    if(global.defenseNeeded >= 20) {
        console.log("defense required")
    }

    global.haulercreations = 0
    for(let temp in Memory.longrangemining) {
        global.haulercreations += Memory.longrangemining[temp].creeps.length
    }
    //Gather info on which spawn for haulers to focus on
    global.haulerfocus=0
    let grab = 0
    let info = 1000000000000
    let keyfix = Game.spawns
    let spawnamount = 0
    for(let a in Game.spawns) {
        Game.map.visual.circle(Game.spawns[a].pos,{fill: "#1E88E5", radius: 1, stroke: "#0D47A1"})
        spawnamount+=1
    }
    global.LRBmake = 0
    global.LRBroom = 0
    for(let temp in Game.rooms) {
        let room = Game.rooms[temp]
        if(!room.controller || room.controller.my===false) {
            continue
        }
        if(room.controller.level <= 4) {
            global.LRBmake = 1
            global.LRBroom = room.name
        }
        let spawn = room.getMasterSpawn()
        if(spawn===null) {
            room.memory.masterspawn=undefined
            continue
        }
        if(spawnamount<=1) {
            grab=spawn.name
            break
        }
        if(spawn.room.storage) {
            if(room.storage.store[RESOURCE_ENERGY]<info&&(spawn.memory.queen!==undefined||spawn.memory.queen2!==undefined||global.restartEco!==undefined)) {
                grab=spawn.name
                info=spawn.room.storage.store[RESOURCE_ENERGY]
            }
        }
    }
    global.haulerfocus=grab
    // Loop through each spawn and manage units and tasks
    for(let roomid in Game.rooms) {
        let room = Game.rooms[roomid]
        global.createdunit = 0
        let currentspawn = room.getMasterSpawn()
        if(!room.controller || room.controller.my===false || currentspawn === undefined||currentspawn===null) {
            continue
        }
        if(currentspawn.memory.harvesters === undefined) {
            currentspawn.memory = {
                harvesters: [],
                builders: [],
                itemrequests: [],
                builderallocations: { upgrade: 0, buildRoad: 0, general: 0 }
            }
        }
        let test = room.find(FIND_STRUCTURES, {
            filter: (structure) => {
                return (structure.structureType == STRUCTURE_EXTRACTOR)
            }
        })
        if(test.length > 0)  {
            global.isextractor = test[0].id;
        } else global.isextractor = undefined
        // Cache the number of extensions in the spawn's room
        Memory.storecache = room.find(FIND_MY_STRUCTURES, {
            filter: (structure) => {
                return (structure.structureType == STRUCTURE_EXTENSION&&structure.isActive());
            }
        }).length;
        let towers = room.find(FIND_STRUCTURES, {
            filter: (structure) => {
                return (structure.structureType == STRUCTURE_TOWER)
            }
        });
        let towerdata = {}
        if(Game.cpu.bucket < 2000) {
            console.log("low bucket, disabling non-needed codebases")
        }
            for(let towerold in towers) {
                let tower = towers[towerold]
                let attackers = tower.room.find(FIND_HOSTILE_CREEPS, {filter: function(creep) {
                    return creep.owner.username !== "chungus3095"
                }})
                if(attackers.length > 0) {
                    let healers = tower.room.find(FIND_HOSTILE_CREEPS, {filter: function(creep) {
                        return creep.owner.username !== "chungus3095" && creep.getActiveBodyparts(HEAL) > 0
                    }})
                    if(towerdata.attackedhealer===1) {
                        attackers = tower.room.find(FIND_HOSTILE_CREEPS, {filter: function(creep) {
                            return creep.owner.username !== "chungus3095" && creep.getActiveBodyparts(HEAL) === 0
                        }})
                        console.log("AAAAA")
                    }
                    if(healers.length > 0&&towerdata.attackedhealer == 0) {
                        attackers = healers
                        towerdata.attackedhealer = 1
                    }
                    attackers.sort((a, b) => a.hits - b.hits);
                    tower.attack(attackers[0])
                } else {
                    let targets = tower.room.find(FIND_STRUCTURES, {
                        filter: object => object.hits < object.hitsMax*0.75 && object.hits < 1000000
                    });

                    // Sort by damage level (most damaged first)
                    targets.sort((a, b) => a.hits - b.hits);

                    // If damaged structures are found, repair the closest one
                    if(targets.length > 0) {
                        tower.repair(targets[0])
                    }
                }

            }
        let alllinks = room.find(FIND_MY_STRUCTURES,{filter: function(structure) {
            return structure.structureType === STRUCTURE_LINK
        }})
        for(let I in alllinks) {
            linktick(alllinks[I]);
        }
        // Set cache to 0 if the controller level is 1
        if(room.controller.level == 1) {
            Memory.storecache = 0;
        }
        global.kill = 0
        if(Game.cpu.bucket >= 2000) {
            if(room.controller.level > 2) {
                let add = 0
                for(let temp in Memory.miningrooms) {
                    let I = Memory.miningrooms[temp]
                    if(I.room ==room.name) {
                        add = 1
                    }
                }
                if(add == 0) {
                    Memory.miningrooms.push({room:room.name, usedSegment: 0})
                }
            }
        }
        // Check for new harvester, builder, and combat units
        if(Memory.longrangemining[Memory.longrangemining.length-1]!==undefined) {
            if(global.LRBmake===1&&Memory.longRangeBuilders.length < 1 && currentspawn.memory.queue.length < 1&&room.controller.level>=5&&global.restartEco===undefined&&Memory.longrangemining[Memory.longrangemining.length-1].creeps.length !== 0) {
                currentspawn.queueAppend(
                    [MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,WORK,WORK,WORK,WORK,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY],
                    {spawnid: currentspawn.id,room:global.LRBroom},
                    "LRB"
                )
            }
        }
        currentspawn.queueCheck()
        let allspawns = room.find(FIND_MY_SPAWNS)
        if(!global.cache) {
            global.cache={}
        }
        for(let spawn of allspawns) {
            let nearby = []
            if(nearby.length<=0) {
                if(room.energyAvailable>=room.energyCapacityAvailable-100) {
                    try {
                        if(spawn.room.getMasterSpawn().memory.queen===undefined&&spawn.room.getMasterSpawn().memory.queen2===undefined&spawn.room.controller.level > 3&&global.restartEco!==undefined) {
                            newhaulercheck(spawn.name);
                            newharvcheck(spawn.name);
                            newbuildcheck(spawn.name);
                            newcombatcheck(spawn.name);
                        } else {
                            newharvcheck(spawn.name);
                            newbuildcheck(spawn.name);
                            newhaulercheck(spawn.name);
                            newcombatcheck(spawn.name);
                        }
                    } catch(err) {
                        console.log("spawn "+spawn+" errored spawning with "+err)
                    }
                }
            }
        }
        global.defenseNeeded -=1
        // Waste of cpu
        /*
        try {
            for(let I in Memory.haulers) {
                if(Game.creeps[Memory.haulers[I]].ticksToLive<1000) {
                    currentspawn.renewCreep(Game.creeps[Memory.haulers[I]])
                }
            }
        } catch(e) {}
        */
        // ||||||||||||||||||||||
        // run for each unit type
        // ||||||||||||||||||||||
        if(currentspawn.memory.harvesters.length > 0) {
            currentspawn.memory.harvesters.forEach(item => harvesterforeach(item, currentspawn.name));
        }
        // Run through each builder in memory and execute its tasks
        if(currentspawn.memory.builders.length > 0) {
            currentspawn.memory.builders.forEach(item => builderforeach(item, currentspawn.name));
        }
        if(Game.cpu.bucket >= 2000) {
            if(currentspawn.memory.minharvs) {
                currentspawn.memory.minharvs.forEach(item => minharvsforeach(item, currentspawn.name));
            }
        }
        if(currentspawn.memory.upgradeRefill!==undefined) {
            if(currentspawn.memory.upgradeRefill in Game.creeps) {
                refillTick(Game.creeps[currentspawn.memory.upgradeRefill])
            } else {
                currentspawn.memory.upgradeRefill = undefined
            }
        }
        if(currentspawn.memory.queen !== undefined) {
            if(currentspawn.memory.queen in Game.creeps) {
                queentick(Game.creeps[currentspawn.memory.queen],"queen1")
            } else {
                currentspawn.memory.queen = undefined
            }
        }
        if(Game.cpu.bucket >= 2000) {
            if(currentspawn.memory.queen2 !== undefined) {
                if(currentspawn.memory.queen2 in Game.creeps) {
                    queentick(Game.creeps[currentspawn.memory.queen2],"queen2")
                } else {
                    currentspawn.memory.queen2 = undefined
                }
            }
            if(room.terminal!==undefined) {
                // too much usage rn
                //terminaltick(room.terminal)
        }
        }
    }
    if(Memory.haulers.length > 0) {
        Memory.haulers.forEach(item => haulerforeach(item,global.haulerfocus));
    }
    if(Game.cpu.bucket >= 2000) {
        for(let temp in Memory.claimers) {
            let claimer = Game.creeps[Memory.claimers[temp]]
            if(claimer === undefined) {
                Memory.claimers[temp] = undefined
                continue
            }
            if(claimer.memory.reserving !== undefined) {
                if(claimer.room.name !== claimer.memory.reserving) {
                    claimer.moveTo(new RoomPosition(25,25,claimer.memory.reserving),{reusePath:40})
                } else {
                    let check = claimer.room.find(FIND_STRUCTURES,{filter: function(structure) {
                        return structure.structureType == STRUCTURE_CONTROLLER
                    }})
                    if(check) {
                        if(claimer.reserveController(check[0]) == ERR_NOT_IN_RANGE) claimer.moveTo(check[0])
                    }
                }
            } else {
                claimer.memory.reserving = Memory.miningrooms[temp].room
            }
        }
        for(let temp in Memory.longRangeBuilders) {
            let Lbuilder  = Memory.longRangeBuilders[temp]
            if(Lbuilder in Game.creeps) {
                LRBtick(Game.creeps[Lbuilder])
            } else {
                Memory.creeps[Lbuilder] = undefined;
                const index = Memory.longRangeBuilders.indexOf(Lbuilder);
                if (index > -1) {
                    console.log("epic");
                    Memory.longRangeBuilders.splice(index, 1);
                    break;
                }
            }
        }
    }
    // Run the miner code for long-range mining logic
    remotetick();
    // ||||||||||||||||||||||
    //  Unit type running end
    // ||||||||||||||||||||||
    // Clear stored creeps if the first stored creep is undefined
    if(Game.creeps[Memory.storedcreeps[0]] === undefined) {
        Memory.storedcreeps = [];
    } else {
        Game.creeps[Memory.storedcreeps[0]].moveTo(9,5,{reusePath: 40})
    }

    // Cleanup memory for creeps that no longer exist
    for(let curcreep in Memory.creeps) {
        if(isUndefined(Game.creeps[curcreep])) {
            Memory.creeps[curcreep] = undefined;
        }
    }


    if(global.fixticks > 1000) {
        Memory.usedsources = new Array();
        Memory.buildersources = new Array();
        Memory.upgradersources = new Array();
        console.log("!! forcefully resetting source allocations, to fix any issues that arise while offline")
        global.fixticks = 0
    }

        // Run through each fighter in memory and execute its tasks
        if(Memory.fighters.length > 0) {
            Memory.fighters.forEach(item => combatforeach(item));
        }
    // Log CPU usage with different warnings based on usage level
    let ecolevel = 3
    if(global.restartEco!==undefined) {
        ecolevel = 2
    }
    if(Memory.haulers.length < 4) {
        ecolevel = 1
    }
    if(Memory.haulers.length < 1) {
        ecolevel = 0
    }
    global.avgcpu.push(Game.cpu.getUsed())
    global.cputrend.push(Game.cpu.getUsed())
    let avg = array => array.reduce((a, b) => a + b) / array.length;
    let stringify = {
        cpuUsage: avg(avgcpu),
        bucket: Game.cpu.bucket,
        ecoStatus: ecolevel
    }
    if(global.avgcpu.length>14) {
        global.avgcpu.splice(0,1)
    }
    if(global.cputrend.length>3000) {
        global.cputrend.splice(0,1)
    }
    RawMemory.segments[1] = JSON.stringify(stringify)
    if(Game.cpu.getUsed()<16) {
        for(let T in Game.creeps) {
            let creep = Game.creeps[T]
            if(creep.memory._move!==undefined) {
                let poly = [new RoomPosition(creep.pos.x,creep.pos.y,creep.room.name)]
                for(let path of Room.deserializePath(creep.memory._move.path)) {
                    poly.push(new RoomPosition(path.x,path.y,creep.room.name))
                }
                Game.map.visual.poly(poly, {stroke: '#ffffff', strokeWidth: .8, opacity: .2, lineStyle: 'dashed'})
            }
        }
    }
    if(Game.cpu.getUsed() >= 20) {
        console.log("tf are you doing, you're at the max cpu! (" + Game.cpu.getUsed() + ")");
    }
}

// Function to handle tasks for each harvester
function harvesterforeach(item, spawntype) {
    if(item in Game.creeps) {
        if(Game.creeps[item].room == Game.spawns[spawntype].room) {
            // Renew harvester if it's near the end of its lifespan
            if(Game.creeps[item].ticksToLive < 1000) {
                Game.spawns[spawntype].renewCreep(Game.creeps[item]);
            }
            // Execute harvester tasks
            if(global.kill==1) {
                remove("usedsources",Game.creeps[item])
                Game.creeps[item].suicide()
            } else {
                harvtick(Game.creeps[item]);
            }
        }
    } else {
        // Remove harvester from memory if it no longer exists
        Memory.creeps[item] = undefined;
        const index = Game.spawns[spawntype].memory.harvesters.indexOf(item);
        if (index > -1) {
            console.log("epic");
            Game.spawns[spawntype].memory.harvesters.splice(index, 1);
        }
    }
}

// Function to handle tasks for each hauler
function haulerforeach(item,focuson) {
    if(item in Game.creeps) {
            // Renew hauler if it's near the end of its lifespan
            // Execute hauler tasks
            haulertick(Game.creeps[item],focuson);
    } else {
        // Remove harvester from memory if it no longer exists
        Memory.creeps[item] = undefined;
        const index = Memory.haulers.indexOf(item);
        if (index > -1) {
            console.log("epic");
            Memory.haulers.splice(index, 1);
        }
    }
}

// Function to handle tasks for each builder
function builderforeach(item, spawntype) {
    if(item in Game.creeps) {
            // Renew builder if it's near the end of its lifespan
            //if(Game.creeps[item].ticksToLive < 1000) {
                //Game.spawns[spawntype].renewCreep(Game.creeps[item]);
            //}
            // Execute builder tasks
            buildertick(Game.creeps[item], spawntype);
    } else {
        // Manage memory cleanup and task allocations if builder no longer exists
        const index =Game.spawns[spawntype].memory.builders.indexOf(item);
        var data = Memory.creeps[item];
        data = {memory: data};
        Memory.creeps[item] = undefined;
        if(data.memory != undefined) {
            if(data.memory.task != undefined) {
                console.log(data.memory.task);
                Game.spawns[spawntype].memory.builderallocations[data.memory.task] -= 1;
                if(data.memory.task == 'general') {
                    remove("buildersources", data);
                }
                if(data.memory.task == 'upgrade') {
                    remove("upgradersources", data);
                }
                data.memory.task = undefined;
            }
        }
        if (index > -1) {
            console.log("test");
            Game.spawns[spawntype].memory.builders.splice(index, 1);
        }
    }
}

// Function to handle tasks for each combat unit
function combatforeach(item) {
    if(item in Game.creeps) {
        // Renew combat unit if it's near the end of its lifespan
        // Execute combat unit tasks
        combattick(Game.creeps[item]);
    } else {
        // Remove combat unit from memory if it no longer exists
        Memory.creeps[item] = undefined;
        const index = Memory.fighters.indexOf(item);
        if (index > -1) {
            Memory.fighters.splice(index, 1);
        }
    }
}
function minharvsforeach(item,spawntype) {
    if(item in Game.creeps) {
            // Renew hauler if it's near the end of its lifespan
            // Execute hauler tasks
            minharvtick(Game.creeps[item]);
    } else {
        // Remove harvester from memory if it no longer exists
        Memory.creeps[item] = undefined;
        const index = Game.spawns[spawntype].memory.minharvs.indexOf(item);
        if (index > -1) {
            console.log("epic");
            Game.spawns[spawntype].memory.minharvs.splice(index, 1);
        }
    }
}
